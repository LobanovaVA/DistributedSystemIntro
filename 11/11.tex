\newpage
\section {Билет 11. Методы шифрования данных.}
В курсе было рассмотрено два метода шифрования:
\begin {itemize}
\item симметричное (т.е. для шифровки и дешифровки используется один и тот же ключ) или с закрытым ключом;
\item асимметричное (т.е. для шифровки и дешифровки используются разные ключи) или с открытым ключом.
\end {itemize}

Далее будет использоваться следующая терминология: мы хотим отправить по открытому каналу связи сообщение $X$, нам его нужно зашифровать, чтобы злоумышленник, просматривающий канал связи, не смог прочитать передаваемое сообщение. Зашифрованное сообщение будем обозначать через $Y$. Степень невозможности прочтения исходного текста, полученного из канала связи в виде шифра, зависит, как правило, от некоторой небольшой информации, имеющейся у отправителя и получателя ее (быть может, различной) и называющейся ключом $K$.

\subsubsection{Симметричное}
\href{https://clck.ru/9KE6e}{Шифр Цезаря} \\
Пусть отправляемое сообщение $X$ составлено из алфавита $A$. Простым шифром подстановки называется шифр вида:

$$ X = (x_1, x_2, \dots x_n), Y = (\sigma (x_1), \sigma(x_2), \dots \sigma(x_n)), \, \text{где}\, \sigma - \text {перестановска букв алфавита А} $$

В оригинальном шифре Цезаря использовался циклический сдвиг на 3 позиции левее. Приведем простой пример: пусть сообщение $X$ имеет вид "Съешь же ещё этих мягких французских булок, да выпей чаю"\,, тогда сообщение $Y$ будет выглядеть "Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб". \\

Все шифры простой замены не устойчивы к взлому (и шифр Цезаря не исключение). В каждом языке одни буквы встречаются часто, а другие - редко. Например, в русском языке самая часто употребляемая буква о, а самая редко употребляемая ф. И эта тенденция сохраняется практически в любом тексте русского языка. Поэтому, можно провести частотный анализ зашифрованного текста $Y$, т.е. посчитать частоту вхождения каждой буквы и соотнести частоты букв зашифрованного текста с общеизвестными частотами букв русского языка.\\
\\
\href{https://clck.ru/TQFhp}{Шифр Вернама} \\
Пусть сообщение $X$ - вектор длины n состоящий из 0 и 1 ($X \in \{0, 1\}^n$), ключ $K$ - выберем такой же длины n, $K \in \{0, 1\}^n$. Тогда зашифруем сообщение $X$ следующим образом: $X \oplus K = Y$, где $\oplus$ - сложение по модулю два происходит покомпонентно. Этот вид шифрования прост и очень надежен, но если к злоумышленнику попадет сообщение $X$ и $Y$, то можно просто найти ключ $K$, так как $K = X \oplus Y$. Поэтому на практике используют другой подход: пусть хотим передать сообщения $X_1, X_2, X_3 \dots X_n$, пусть выбран какой-то ключ $K_1$, и шифр $Y_1$ получается по правилу $Y_1 = X \oplus K$. Тогда на шаге $i$ ключ $K_i = f (K_{i - 1}, X_i \dots X_1)$, где $f()$ - некоторая функция. Тогда даже если будет перехвачен $Y_i$ и $X_i$ и будет получен $K_i$, то предыдущие сообщения останутся не расшифрованными, так как они кодировались другими ключами. \\
\\
\href{https://clck.ru/UNdXg}{Блочный шифр} \\
Пусть есть последовательность сообщений одинаковой длинны $X_1, X_2, X_3 \dots X_n, X_i \in \{0, 1\}^n$ которую мы хотим передать по открытому каналу связи. Пусть есть последовательность пар $(\sigma_1, K_1), (\sigma_2, K_2), \dots (\sigma_i, K_i) \dots$ где $\sigma$- это перестановка на множестве букв алфавита $A$, $K_i$ - вектор из 0 и 1, $K_i \in \{0, 1\}^n$. Тогда ключом мы назовем последовательность пар т.е. $K = ((\sigma_{i_1}, K_{i_1}), (\sigma_{i_2}, K_{i_2}), (\sigma_{i_n}, K_{i_n}))$ и шифрование происходит так: сначала к сообщению $X_1$ применяется перестановка букв $\sigma_{i_1}$, к результату применяется шифр Вернама с ключом $K_{i_1}$ и так далее, к сообщению $X_2$ применяется перестановка $\sigma_{i_2}$, потом шифр Вернама с ключом $K_{i_2}$ и т.д.

Возникает логичный вопрос, как передать ключ для расшифровки? \\

\subsubsection{Способы передачи ключа}

\begin {itemize}
\item Пусть по открытому каналу связи общаются Алиса (A) и Боб (B), и им нужно передать ключ. Пусть есть две функции $f_{A}, f_{B}$, к которым известны обратные $f^{-1}_{A}, f^{-1}_{B}$ и которые обладают свойством $f_{A} (f_{B} (x)) = f_{B} (f_{A} (x))$. Тогда для передачи ключа $k$ от A к B используется следующий алгоритм:
\begin {itemize}
\item A отправляет B сообщение $f_{A} (k)$;
\item B отправляет A сообщение $f_{B}(f_{A} (k))$;
\item A отправляет B сообщение $f^{-1}_{A}(f_{B}(f_{A} (k)))$;
\item B применяет к сообщению $f^{-1}_{B}$ и получает $f^{-1}_{B}(f^{-1}_{A}(f_{B}(f_{A} (k)))) = k$.
\end {itemize}
В качестве $f_{A}, f_{B}$ - обычно используют функции возведения в степень по модулю. \\

\item \href{https://clck.ru/9rNPo} {Протокол Диффи—Хеллмана}\\
Не всегда требуется передать ключ от одного пользователя к другому, иногда достаточно выработать единый. 
\begin {itemize}
\item А придумывает $N$ - модуль по которому будут проводится сравнения, $a, X$ - вычеты по модулю $N$. A отправляет В тройку $(X, N, X^{a} \, (mod \, N))$;
\item B придумывает показатель $b$ и отправляет А $X^{b}$;
\item В итоге у А и В формируется одинаковое число $\left( X^{b} \right)^{a}$.
\end {itemize}
\end{itemize}
На первый взгляд можно подумать, что взлом схемы очевиден, ведь достаточно знать показатели степени $a, b$, а для этого необходимо лишь прологарифмировать сообщения $X^a, X^b$, а так как мы знаем сообщение $X$ - то можно узнать и показатель. Но не существует эффективного поиска логарифма числа по модулю $N$ (см. \href{https://clck.ru/pv4S6}{Дискретный логарифм}). Поэтому на практике данная процедура займет бесконечно много времени.

\subsubsection{Асимметрические алгоритмы (Алгоритмы с открытым ключом)}

В лекциях был разобран  RSA алгоритм. Задача формулируется аналогичным образом: мы хотим отправить по открытому каналу связи сообщение $X$, нам его нужно зашифровать, чтобы злоумышленник, просматривающий канал связи, не смог прочитать передаваемое сообщение. \\

Перед тем как рассказать суть RSA алгоритма вспомним теорему Эйлера. \\
\begin{theorem} (Эйлер). Если Числа X и N взаимнопросты, то тогда $X^{\varphi (N)} \, = \, 1 \, (mod \, N)$ \end{theorem}
$\varphi$ - функция Эйлера. Например, для простого числа $p$ его функция Эйлера $\varphi (p) = p - 1$. \\

Вспомним давних товарищей, общающихся по каналу связи, Алису (A) и Боба (B). Пусть сообщение передает Боб.
Алиса берет число $N = pq$, p,q - различные простые числа. Тогда $\varphi (N) \, = \, (p - 1)(q - 1)$. И подбирает число $e$ так, чтобы $(e, \varphi(N)) \, = \,1$. С помощью Алгоритма Евклида ищется $d$ такое, что  $ed = 1 (mod \, \varphi (N))$. Тогда сам алгоритм выглядит следующим образом:
\begin {itemize}
\item A передает В пару $(N, e)$. e - открытый ключ, d - секретный;
\item B передает сообщение $X^e$;
\item A полученное сообщение возводит в степень $d$ т.е. $(X^e)^d = X (mod N)$.
\end {itemize}

Злоумышленник не может перехватить сообщение $X$ по двум причинам: сложность разложения числа $N$ на простые множители (так как надо по числу $e$ определить число $d$, для этого нужно посчитать функцию Эйлера, а для этого нужно разложить число на простые множители, чтобы воспользоваться свойствами мультипликативности функции Эйлера) и проблема дискретного логарифма.

\subsubsection{Цифровая подпись}

Как Алисе убедить Боба, что она автор сообщения $X$? Очень просто. Пусть как в предыдущем пункте Алиса выберет $e, d, N$ так, чтобы $ed \, = \,1 \,(mod \, \varphi (N))$. Тогда в открытом доступе Алиса публикует пару $(e, N)$ и  $(X, X^d)$. Боб делает проверку: берет $X^d$ из открытого доступа и возводит в степень $e$ и смотрит совпадает ли полученное сообщение с $X$  т.е. выполнено ли, что $X \, = \, (X^d)^e \, (mod \, \varphi (N))$. На этом простом примере основан принцип электронной (цифровой) подписи. Электронная подпись позволяет подтвердить авторство электронного документа. Например, Алиса при отправке сообщения $X$ Бобу сначала отправляет сообщение в "Удостоверяющий Центр"\,, который генерирует числа $e, d, N$. "Центр" пересылает Бобу пару $(X, X^e)$, а Боб с помощью открытого ключа проверяет, что документ отправлен Алисой. Удостоверяющие центры могут выстраиваться по иерархии, и центры, находящиеся выше, подтверждают подписи, накладываемые центрами ниже.





